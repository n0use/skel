pass () 
{ 
    user=$1;
    if [ -z "$1" ] ; then
        for f in ${HOME}/etc/pass/password-* ; do
            p=$(basename ${f})
            echo ${p} | sed 's/^password-\(.*\).txt.*$/\1/'
        done
        return 0
    fi
    pass_file="${HOME}/etc/pass/password-${user}.txt"
    if [ -f "${pass_file}" ] ; then
        echo "Warning: you have an UNENCRYPTED PASSWORD FILE (${pass_file}).. you should remove this file for security reasons."
        cat "${pass_file}" 
        return 0
    fi
    if [ ! -f ${HOME}/etc/pass/password-${user}.txt.gpg ]; then
        echo "No password for \"${user}\" stored.";
        possibles=$(ls ${HOME}/etc/pass/password-* | sed "s#${HOME}/etc/pass/password-##" | sed 's/.txt.gpg$//' | grep -i ${user})
        if [ -n "${possibles}" ] ; then
            echo "Did you mean one of these - "
#            for p in $(echo ${possibles} | sed 's/ /\n/g' | | sed 's/.txt.gpg$//') ; do
            for p in ${possibles} ; do
                echo "  ${p}"
            done
        fi
        return 1;
    fi;
#    gpg -d ${HOME}/etc/pass/password-${user}.txt.gpg > /tmp/p.$$ && clear && cat /tmp/p.$$ && rm -f /tmp/p.$$
    gpg -d ${HOME}/etc/pass/password-${user}.txt.gpg > /tmp/p.$$ && cat /tmp/p.$$ && rm -f /tmp/p.$$
}

newpass ()
{
    pass=$1;
    if [ -z "${pass}" ] ; then
        echo "Usage: newpass name-of-pass";
        echo " After it launches type in the encrypted password info you want to store, as many lines as you want,";
        return 1;
    fi
    pass_file="${HOME}/etc/pass/password-${pass}.txt"

    if [ -f "${pass_file}" ] || [ -f "${pass_file}.gpg" ] ; then
        echo "There is already a password stored for this - remove the old one and try again."
        return 1
    fi
    echo "Enter the information to store in the encrypted file for \"${pass}\""
    cnt=0
    input=()
    while read line ; do
        input[${cnt}]="$line"
        cnt=$(($cnt + 1))
    done
    for ((i=0;i<${cnt};i++)) do
        echo "${input[${i}]}" >> "${pass_file}"
    done
    gpg -e "${pass_file}"
    rm "${pass_file}"
}

rmpass()
{
    pass=$1;
    pass_file="${HOME}/etc/pass/password-${pass}.txt.gpg";
    if [ ! -f "${pass_file}" ] ; then
        echo -e "There is no stored encrypted password for ${pass}\n - the file would be \"${pass_file}\"\n\nSKIPPING DELETION - it DOESNT EXIST!";
        return 1
    fi
    
    echo -en "Are you sure you want to erase the $1 password file?\n -  stored in \"$pass_file\"? [yN] ";
    read yesno;
    if [[ "${yesno}" =~ ^[yY].* ]] ; then
        echo "Removing \"$pass_file\"";
        echo rm \"$pass_file\" | sh -x
    else
        echo "OK, leaving ${pass} (file is \"$pass_file\") in place."
    fi
}
# this functtion scans the current directory for .sig GnuPG/PGP signatures
#  and their cooresponding files, and does a gpp/gpg2 --verify on all of them

function gverify
{
    verbose=""
    nargs=$#
    if [[ "$1" == "-v" ]] ; then
        verbose="-v"
        nargs=$((nargs - 1))
        shift
    fi

    total=0
    for f in *.sig ; do 
        # there are no actual files so it defaults to just using the 
        # glob
        fname=$(basename $f .sig)
        if [[ "$f" == "*.sig" ]] ; then
            echo "No signature files found!"
            break
        fi
        if [ ! -f "$fname" ]  ; then 
            echo "Signature [$f] found, but file [$fname] missing.."
            continue
        fi
        echo "Checking $fname.."
        [ -n "$verbose" ] && echo " Using signature file $f."
        [ -n "$verbose" ] && echo " + gpg2 --verify $f $fname"
        gpg2 $verbose --verify $f $fname && echo 
        total=$((total +1 ))
    done
}
